(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
function BufferLoader(context, urlList, callback) {
    this.context = context;
    this.urlList = urlList;
    this.onload = callback;
    this.bufferList = new Array();
    this.loadCount = 0;
}

BufferLoader.prototype.loadBuffer = function(url, index) {
    // Load buffer asynchronously
    var request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = "arraybuffer";

    var loader = this;

    request.onload = function() {
        // Asynchronously decode the audio file data in request.response
        loader.context.decodeAudioData(
            request.response,
            function(buffer) {
                if (!buffer) {
                    alert('error decoding file data: ' + url);
                    return;
                }
                loader.bufferList[index] = buffer;
                if (++loader.loadCount == loader.urlList.length)
                    loader.onload(loader.bufferList);
            },
            function(error) {
                console.error('decodeAudioData error', error);
            }
        );
    }

    request.onerror = function() {
        alert('BufferLoader: XHR error');
    }

    request.send();
}

BufferLoader.prototype.load = function() {
    for (var i = 0; i < this.urlList.length; ++i)
        this.loadBuffer(this.urlList[i], i);
}

module.exports = BufferLoader;
},{}],2:[function(require,module,exports){
var BufferLoader = require('./BufferLoader');

const colors = [

    // [ 252.0, 208.0, 161.0 ],
    // [ 177.0, 182.0, 149.0 ],
    // [ 166.0, 144.0, 164.0 ],
    // [  94.0,  75.0,  86.0 ],
    // [ 175.0, 210.0, 233.0 ]

    [142.0, 58.0, 111., 1.],
    [151.0, 69.0, 126., 1.],
    [165.0, 101., 85.0, 1.],
    [179.0, 138., 86.0, 1.],
    [186.0, 146., 63.0, 1.]

];
colors.forEach(function(color){
    color[0] /= 255.0;
    color[1] /= 255.0;
    color[2] /= 255.0;
});
// colors.forEach(function(color){
//     for (let i = 0; i < color.length; i++) {
       // // color[i] ^= 1.0;
    // }
// });

const COL_PRIMARY = 2;
const COL_SECONDARY = 0;


const SCALE = 4;



const glsl_vs1 = `
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoordinates;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;

varying vec2 vTextureCoordinates;
varying vec2 pos;

void main() {
    vTextureCoordinates = aTextureCoordinates;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(aVertexPosition, 1.0);
    pos = vec2(aVertexPosition.x, aVertexPosition.y);
}`;

const glsl_fs1 = `
#ifdef GL_ES
precision highp float;
#endif

varying vec2 vTextureCoordinates;

varying vec2 pos;

uniform float time;
uniform sampler2D tex0;

void main() {
    // Procedural penrose tiling
    // 2011 (C) Tomasz Dobrowolski
    // http://moonedit.com/tom
    
    // This is based on Robinson substitution,
    // prototiles are two iosceles triangles,
    // type 0 with angles: 36, 36, 108 deg.
    // type 1 with angles: 72, 72, 36 deg.

    const int levels = 7;         // number of substitutions
    const float sc = 1.6180339887498947; // = 2.0/(sqrt(5.0)-1.0) (inflation scale)
    const float pi = 3.1415926535897931;

    // transformations constants:

    const float d1 = 1.3763819204711734; // = tan(54*pi/180)
    const float d2 = 0.32491969623290629; // = tan(18*pi/180)
    const float a1 = 0.61803398874989479; // = .5/cos(36*pi/180)
    const float a2 = 0.80901699437494745; // = (1+a1)*.5
    const float a3 = 0.5877852522924728; // = tan(36*pi/180)*a2
    const float cos1 = -1.3090169943749466; // = cos(144*PI/180)*sc
    const float sin1 = 0.95105651629515331; // = sin(144*PI/180)*sc
    const float cos2 = -0.5; // = cos(108*PI/180)*sc
    const float sin2 = 1.5388417685876261; // = sin(108*PI/180)*sc


    int type = 0;
    float x, y, xx, yy, co, si;

    const float TIME_SCALE = 0.00009; 


    // simple roto-zooming:
    co = cos(time*.6*TIME_SCALE)*.5;
    si = sin(time*TIME_SCALE)*.5;
    xx = vTextureCoordinates.s - .5;
    yy = vTextureCoordinates.t - .5;
    x = xx*co + yy*si + .8;
    y = -xx*si + yy*co;
    y = abs(y);


    for (int k=0; k < levels; k++)  // iterate all subsitutions
    {
        if (type == 0)
        {
            // We substitute triangle type 0
            // with three possible triangles.
            // We detect in which of those three
            // triangle our current (x,y) lies
            // by checking line equations separating them:

            if (1.0 - d1*y - x > 0.0) // left triangle
            {
                // only translation/mirror here:
                x = (1.0 - x)*sc;
                y = y*sc;
            }
            else if (1.0 - d2*y - x > 0.0) // middle triangle
            {

                // translate:
                xx = x - a2;
                yy = y - a3;

                // rotate:
                x = xx*cos1 - yy*sin1;
                y = xx*sin1 + yy*cos1;

                type = 1; // tile type changes here!
            }
            else // right triangle
            {
                // translate (x only):
                xx = x - (1.0+a1);
                yy = y;

                // rotate:
                x =  xx*cos1 + yy*sin1;
                y = -xx*sin1 + yy*cos1;
            }
        }
        else
        {
            // We substitute triangle type 1 with
            // two possible triangles (analogically).

            if (d1*y - x > 0.0) { // upper triangle

                // rotate only
                xx = x;
                yy = y;
                x = -xx*cos2 + yy*sin2;
                y =  xx*sin2 + yy*cos2;

                type = 0; // tile type changes here!

            } else { // lower triangle

                // translate (x only):
                xx = x - a1;
                yy = y;

                // rotate:
                x =  xx*cos2 + yy*sin2;
                y = -xx*sin2 + yy*cos2;
            }
        }
    }

    // shading:
    float d;

    if (type == 0) {
        d = (1.0 - (x*x + y*y))*.142;
    } else {
        d = ((x-a1)*(x-a1) + y*y);
    }
    if (d >= 0.0 && d < .25*.25) {
        gl_FragColor.rgba = vec4(${colors[COL_PRIMARY][0]},${colors[COL_PRIMARY][1]},${colors[COL_PRIMARY][2]},1.0);
        // r = .85;
        // g = .83;
        // b = .46;
    } else {
        d = 1.0 - d;
        gl_FragColor.rgba = vec4(${colors[COL_SECONDARY][0]}*d,${colors[COL_SECONDARY][1]}*d,${colors[COL_SECONDARY][2]}*d,1.0);

        // r = 0.19*d;
        // g = 0.29*d;
        // b = 0.65*d;
    }


    // gl_FragColor = vec4(r, g, b, 1.0);
}`;







var canvas = document.getElementById('anim');
var gl = canvas.getContext('experimental-webgl');
resizeCanvas();

gl.clearColor(0.0, 0.0, 0.0, 1.0);
gl.enable(gl.DEPTH_TEST);

// create buffer with a rectangle
var vertexPositionsBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionsBuffer);
var vertexPositions = [
    1.0, 1.0, 0.0,
    -1.0, 1.0, 0.0,
    1.0, -1.0, 0.0,
    -1.0, -1.0, 0.0
];

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositions), gl.STATIC_DRAW);
vertexPositionsBuffer.itemSize = 3;
vertexPositionsBuffer.numItems = 4;

// create buffer with texture coordinates
var textureCoordinatesBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinatesBuffer);
var s = 1.0;
var t = (1.0 - gl.canvas.height / gl.canvas.width)*.5;
var textureCoordinates = [
    s, t,
    0.0, t,
    s, 1.0-t,
    0.0, 1.0-t
];

gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoordinates), gl.STATIC_DRAW);
textureCoordinatesBuffer.itemSize = 2;
textureCoordinatesBuffer.numItems = 4;

var modelViewMatrix = mat4.create();
var projectionMatrix = mat4.create();

var texture = createTexture("assets/img/concrete1.jpg");
var program = createShaderProgram(vertexPositionsBuffer, textureCoordinatesBuffer);
gl.useProgram(program);




function createShaderProgram(vertexPositionsBuffer, textureCoordinatesBuffer) {
    // create vertex shader
    var vertexShader = gl.createShader(gl.VERTEX_SHADER);
    gl.shaderSource(vertexShader, glsl_vs1);
    gl.compileShader(vertexShader);
    if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(vertexShader));
    }

    // create fragment shader
    var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
    gl.shaderSource(fragmentShader, glsl_fs1);
    gl.compileShader(fragmentShader);
    if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        alert(gl.getShaderInfoLog(fragmentShader));
    }

    // create and use program
    var program = gl.createProgram();
    gl.attachShader(program, vertexShader);
    gl.attachShader(program, fragmentShader);
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        alert(gl.getProgramInfoLog(program));
    }

    // vertex attribute [position]
    program.vertexPositionAttribute = gl.getAttribLocation(program, "aVertexPosition");
    gl.enableVertexAttribArray(program.vertexPositionAttribute);
    //gl.vertexAttribPointer(program.vertexPositionAttribute, vertexPositionsBuffer.itemSize, gl.FLOAT, false, 0, 0);

    // vertex attribute [texture coordinates]
    program.textureCoordinatesAttribute = gl.getAttribLocation(program, "aTextureCoordinates");
    gl.enableVertexAttribArray(program.textureCoordinatesAttribute);
    //gl.vertexAttribPointer(program.textureCoordinatesAttribute, textureCoordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);

    // uniform variables [modelViewMatrix and projectionMatrix]
    program.mvMatrixUniform = gl.getUniformLocation(program, "modelViewMatrix");
    program.pMatrixUniform = gl.getUniformLocation(program, "projectionMatrix");
    program.tex0Uniform = gl.getUniformLocation(program, "tex0");
    program.timeUniform = gl.getUniformLocation(program, "time");

    return program;
}

function createTexture(url) {
    var texture = gl.createTexture();
    texture.image = new Image();
    texture.image.onload = function() {
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, texture.image);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.bindTexture(gl.TEXTURE_2D, null);
    }
    texture.image.src = url;
    return texture;
}

function updateMatrices(program, mvMatrix, pMatrix) {
    gl.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);
    gl.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
}

function updateTexture(program, texture) {
    gl.uniform1i(program.tex0Uniform, 0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texture);
}

function updateTime(program, time) {
    gl.uniform1f(program.timeUniform, time);
}

function frame(deltaTime) {
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    // mat4.perspective(45, gl.canvas.width/gl.canvas.height, 0.1, 100.0, projectionMatrix);
    mat4.ortho(projectionMatrix,-1.0, 1.0, -1.0, 1.0, 0.1, 100.0);
    mat4.identity(modelViewMatrix);
    mat4.translate(modelViewMatrix, modelViewMatrix, [0.0, 0.0, -2.0]);

    updateMatrices(program, modelViewMatrix, projectionMatrix);
    //updateTexture(program, texture);
    updateTime(program, performance.now());

    // plug buffers to the corresponding vertex attributes
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexPositionsBuffer);
    gl.vertexAttribPointer(program.vertexPositionAttribute, vertexPositionsBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.bindBuffer(gl.ARRAY_BUFFER, textureCoordinatesBuffer);
    gl.vertexAttribPointer(program.textureCoordinatesAttribute, textureCoordinatesBuffer.itemSize, gl.FLOAT, false, 0, 0);
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, vertexPositionsBuffer.numItems);

    window.requestAnimationFrame(frame);
}

window.requestAnimationFrame(frame);


window.addEventListener('resize', resizeCanvas, false);
function resizeCanvas() {
    canvas.width = window.innerWidth / SCALE;
    canvas.height = window.innerHeight / SCALE;

    gl.viewport(0, 0, gl.canvas.clientWidth, gl.canvas.clientHeight);
}

/**@TODO: Resize canvas on resize*/
/**@TODO: Optimize*/
/**@TODO: change colours*/


/****************************************************************************************
 *
 *   AUDIO
 *
 **********************************************************************/





/*******
 *  @TODO: fix audio playing on mobile & in desktop chrome :)
 */
var context;
var bufferLoader;

function init() {
    // Fix up prefixing
    window.AudioContext = window.AudioContext || window.webkitAudioContext;
    context = new AudioContext();

    bufferLoader = new BufferLoader(
        context,
        ['./assets/sfx/Polegnala Slowed.ogg'],
        finishedLoading
    );

    bufferLoader.load();
}

function finishedLoading(bufferList) {
    // Create two sources and play them both together.
    var source1 = context.createBufferSource();
    source1.buffer = bufferList[0];
    source1.connect(context.destination);
    source1.start(0);
}
init();









/****************************************************************************************
 *
 *   UI
 *
 **********************************************************************/



function ready(fn) {
    if (document.readyState != 'loading'){
        fn();
    } else if (document.addEventListener) {
        document.addEventListener('DOMContentLoaded', fn);
    } else {
        document.attachEvent('onreadystatechange', function() {
            if (document.readyState != 'loading')
                fn();
        });
    }
}




function goede() {
    let a = "";
    let hours = new Date().getHours();
    if (hours < 6) a = "nacht";
    else if (hours < 12) a = "ochtend";
    else if (hours < 18) a = "middag";
    else a = "avond";
    return a;
}



ready(function() {
    let E_goede = document.getElementById('goede');
    E_goede.innerHTML = "Goeie"+goede()+",";



    let E_navs = document.querySelectorAll('nav a');
    E_navs.forEach(el => el.addEventListener('click', function() {
        let E_sections = document.querySelectorAll('.section');
        E_sections.forEach(function(el) {
            el.classList.remove('active');
        });

        let id = this.innerHTML.replace(' ', '-');
        let E_section = document.getElementById(id);
        E_section.classList.add('active');

    }));


});
},{"./BufferLoader":1}]},{},[2])